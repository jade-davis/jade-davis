        -:    0:Source:graph_tests.cpp
        -:    0:Graph:graph_tests.gcno
        -:    0:Data:graph_tests.gcda
        -:    0:Runs:1
        -:    1:#include <iostream>
        -:    2:#include <sstream>
        -:    3:#include "graph.h"
        -:    4:
        -:    5://using std::cout, std::endl;
        -:    6:
        1:    7:int main() {
        1:    8:    std::cout << "make an empty digraph" << std::endl;
        2:    9:    Graph G;
        -:   10:
        1:   11:    std::cout << "add vertices" << std::endl;
        8:   12:    for (size_t n = 1; n <= 7; n++) {
        7:   13:        G.add_vertex(n);
        -:   14:    }
        -:   15:
        1:   16:    std::cout << "add directed edges" << std::endl;
        1:   17:    G.add_edge(1, 2, 5);  // 1 ->{5} 2; (edge from 1 to 2 with weight 5)
        1:   18:    G.add_edge(1, 3, 3);
        1:   19:    G.add_edge(2, 3, 2);
        1:   20:    G.add_edge(2, 5, 3);
        1:   21:    G.add_edge(2, 7, 1);
        1:   22:    G.add_edge(3, 4, 7);
        1:   23:    G.add_edge(3, 5, 7);
        1:   24:    G.add_edge(4, 1, 2);
        1:   25:    G.add_edge(4, 6, 6);
        1:   26:    G.add_edge(5, 4, 2);
        1:   27:    G.add_edge(5, 6, 1);
        -:   28:
        1:   29:    std::cout << "Result of adding edge to none existing vertex is " << G.add_edge(7, 5, 1) << std::endl;
        1:   30:    std::cout << "Result of adding already existing edge to the graph is " << G.add_edge(7, 5, 1) << std::endl;
        1:   31:    std::cout << "Result of adding edge to none existing vertex is " << G.add_edge(9, 8, 5) << std::endl;
        -:   32:
        1:   33:    std::cout << "G has " << G.vertex_count() << " vertices" << std::endl;
        1:   34:    std::cout << "G has " << G.edge_count() << " edges" << std::endl;
        1:   35:    std::cout << std::endl;
        -:   36:
        1:   37:    std::cout << "Testing for = operator" << std::endl;
        1:   38:    Graph new_G;
        1:   39:    new_G = G;
        1:   40:    std::cout << "new_G has " << new_G.vertex_count() << " vertices" << std::endl;
        1:   41:    std::cout << "new_G has " << new_G.edge_count() << " edges" << std::endl;
        1:   42:    std::cout << std::endl;
        -:   43:
        1:   44:    std::cout << "Testing for creating new graph with new Graph(G)" << std::endl;
        1:   45:    Graph *new_ptr_G = new Graph(G);
        1:   46:    std::cout << "new_ptr_G has " << new_ptr_G->vertex_count() << " vertices" << std::endl;
        1:   47:    std::cout << "new_ptr_G has " << new_ptr_G->edge_count() << " edges" << std::endl;
        1:   48:    std::cout << std::endl;
        -:   49:
        1:   50:    std::cout << "Testing for contains edges" << std::endl;
        1:   51:    std::cout << "Result of containing edge " << new_G.contains_edge(4, 1) << std::endl;
        1:   52:    std::cout << "Result of non containing edge " << new_G.contains_edge(1, 5) << std::endl;
        1:   53:    std::cout << std::endl;
        -:   54:
        1:   55:    std::cout << "Testing for cost edges" << std::endl;
        1:   56:    std::cout << "Result of containing edge " << new_G.cost(4, 1) << std::endl;
        1:   57:    std::cout << "Result of non containing edge " << new_G.contains_edge(1, 5) << std::endl;
        1:   58:    std::cout << std::endl;
        -:   59:
        1:   60:    std::cout << "Remove vertex test" << std::endl;
        1:   61:    std::cout << "Result of containing vertex " << new_G.remove_vertex(4) << std::endl;
        1:   62:    std::cout << "Result of non containing vertex " << new_G.remove_vertex(10) << std::endl;
        -:   63:
        1:   64:    std::cout << "new_G has " << new_G.vertex_count() << " vertices" << std::endl;
        1:   65:    std::cout << "new_G has " << new_G.edge_count() << " edges" << std::endl;
        1:   66:    std::cout << std::endl;
        -:   67:
        1:   68:    std::cout << "Remove edge test" << std::endl;
        1:   69:    std::cout << "Result of containing edge " << new_G.remove_edge(5, 4) << std::endl;
        1:   70:    std::cout << "Result of non containing edge " << new_G.remove_edge(5, 3) << std::endl;
        -:   71:
        1:   72:    std::cout << "new_G has " << new_G.vertex_count() << " vertices" << std::endl;
        1:   73:    std::cout << "new_G has " << new_G.edge_count() << " edges" << std::endl;
        -:   74:
        1:   75:    delete new_ptr_G;
        -:   76:
        -:   77://    std::cout << "compute mst path from 2" << std::endl;
        -:   78://    G.prim(2);
        -:   79://
        -:   80://    std::cout << "print minimum spanning paths" << std::endl;
        -:   81://    for (size_t n = 1; n <= 7; n++) {
        -:   82://        std::cout << "minimum spanning path from 2 to " << n << std::endl;
        -:   83://        std::cout << "  ";
        -:   84://        G.print_path(n);
        -:   85://    }
        -:   86://    std::cout << std::endl;
        -:   87://
        -:   88://    std::cout << "compute shortest path from 2" << std::endl;
        1:   89:    G.dijkstra(2);
        -:   90://
        1:   91:    std::cout << "print shortest paths" << std::endl;
        9:   92:    for (size_t n = 0; n <= 7; n++) {
        8:   93:        std::cout << "shortest path from 2 to " << n << std::endl;
        8:   94:        std::cout << "  ";
        8:   95:        G.print_shortest_path(n);
        -:   96:    }
        1:   97:    G.dijkstra(1);
        9:   98:    for (size_t n = 0; n <= 7; n++) {
        8:   99:        std::cout << "shortest path from 1 to " << n << std::endl;
        8:  100:        std::cout << "  ";
        8:  101:        G.print_shortest_path(n);
        -:  102:    }
        -:  103:
        1:  104:    return 0;
        -:  105:}
        -:  106:
        -:  107:
